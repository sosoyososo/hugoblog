---
title: 'swift3的访问控制有多烦人？'
date: Tue, 05 Sep 2017 02:36:40 +0000
draft: false
tags: ['swift']
---

swift使用5个关键字，在模块，文件和代码块三个级别上进行控制。

### 级别：

**_模块_**是一次性打包的代码，比如一个你的App的一个target，一个framework。 **_文件_** 是一个单独的 \*.swift 代码文件 **_代码块_** 是在这个位置定义的局部变量的作用域

### 关键字:

**_open/public_**　 修饰的内容作用域：　定义的模块内部 +　引用定义模块的文件内部 **_　internal　_**　作用于定义的模块内部 **_　fileprivate　_**　作用于定义的文件内部 **_　private　_**　作用于定义的代码块内部 这样看来还是简单的，但难的永远不是原理，而是对各种细节的处理，越是上手简单的语言，细节就越多，反过来就不一定成立。 ####　open vs. public **_open_** 只能修饰类和类成员。修饰的类可以在定义的模块和引入的模块中被继承，修饰的类成员可以在定义模块和被引入的模块中被覆盖。 **_public_** 定义的类只能在定义模块内部被继承，定义的类成员，只能在定义模块内部被子类覆盖。

### 基本原则

不要在低访问级别的元素内部定义高访问级别的元素。

### 默认的访问级别

没有明确指定，都是internal(个别情况除外) **_public和internal修饰的类_** 成员默认是internal **_private和fileprivate_** 的类，成员的默认级别被降级为类的访问级别。 **_元组_**的访问级别是元组元素的最低级别，并且不能像其他类型一样手动指定 **_协议的成员_** 级别跟协议一致

### 单元测试

通过使用 @testable 来修饰引入的模块，单元测试target可以访问这个模块的internal修饰的元素，并在允许测试的情况下编译这个产品。 ###　函数 函数的默认访问级别是所有参数和返回值的最低级别，当前位置所决定的默认级别如果跟计算出来的不一致，你必须手动指定，来修改错误。

### 枚举类型

case自动的级别跟枚举类型一致，不能被改变。 ####　Raw Values and Associated Values 他们的类型的级别至少应该跟枚举类型一致。比如，internal级别的枚举，不能使用使用public类型作为Raw Value 的类型

### 嵌套的类型

嵌套类型的默认访问级别，跟同级别的成员的默认类型一致(默认是internal，但会因为外层类型的级别低而被降级)

### 子类

可以继承当前位置可以访问的所有类，但子类的级别不能高于父类。 可以覆盖所有可以访问的成员。 覆盖的元素可以比原来的元素有更高的访问级别 只要情况允许，子类成员可以访问比自己级别低的父类成员 ###变量　常量　属性　下标 **变量　常量　属性** 级别不能高于类型级别 **下标** 级别不能高于类型和返回值的最低级别 ####　getter 和 setter **变量　常量　属性　下标**的getter 和 setter跟他们自身的级别一致，setter可以被设置的比getter低 ###初始化 自定义初始化函数可以有不高于类型的级别 required 初始化函数的级别必须跟类型一致 初始化函数的参数类型的访问级别不能低于函数 ###默认初始化 public class 的默认初始化的访问级别是internal， 其他级别的类型，默认初始化的级别跟类型一致 ###结构体的默认成员宽度初始化 不高于最低的存储属性，默认最高为internal

### protocol

成员的级别跟协议一致(默认不是internal)，不能被修改

#### 继承协议

子协议最高拥有父协议的访问级别 ####遵守协议 可以遵守任何可以访问到的协议，但遵守协议提供的功能的级别不高于本身和协议的最低者。如果位置赋予的级别高于得到级别，需要手动指定。 ###extension 在任何可访问的地方都可以扩展，扩展的成员的级别跟原类型成员一致。 扩展的级别不能高于原类型 扩展级别低于原类型的时候，会压低扩展成员的级别 扩展成员可以指定比扩展和原类型相同或者更低的级别 ####　扩展遵守协议 这时候不能手动指定访问级别 对协议的实现，默认是协议的访问级别

### 泛型

泛型类型或者函数的级别受限与他自己定义的级别、他引用的类型的级别的最低者

### 类型别名

被当成单独的类型对待，可以有不高于原类型的级别，可以修改