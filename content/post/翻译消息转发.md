---
title: '(翻译)消息转发'
date: Mon, 29 Dec 2014 12:52:32 +0000
draft: false
tags: ['Read Note']
---

[原文](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1)是Objective-C Runtime Programming Guide文档的Message Forwarding部分 发送一个不被响应的消息到一个对象是错误的，但在报错之前，运行时系统给这个对象第二次机会来处理这种消息。 **转发** 如果你发送一个不响应的消息到一个对象，在报错之前，运行时系统向这个对象发送一个forwardInvocation:消息，并传递以恶搞NSInvovation对象做为唯一参数。这个对象封装了原始消息和它携带的参数。 你在实现forwardInvocation:方法的时候，可以给一个消息的默认响应，或者使用其他方法来避免错误。就像方法名所暗示的，forwardInvocation:通常用于将一个消息转发到其他对象。 想象一下下面的长情来看清转发的范围和目的:首先，假设你在设计一个可以响应negotiate消息的对象，并且你希望它的响应包含其他类型的对象。你可以简单的在negotiate方法实现中传递给另外一个对象negotiate消息来达到这个目的。 我们深入一步，假设你希望你的对象响应negotiate消息，而这个消息的实现是在另外一个类中。但是，这可能就不能实现了。特别是当你的类和实现negotiate消息的类在不同继承分支的时候。 即使你的类不能继承negotiate方法，你仍然可以通过实现一个版本的这个方法，简单的传递这个消息给另外一个类的对象来"借用"它: `- (id)negotiate { if ( [someOtherObject respondsTo:@selector(negotiate)] ) return [someOtherObject negotiate]; return self; }` 做这样的事情是有些讨厌的，特别是当你有一些列的消息需要传递到其他对象的时候。你需要为每个需要传递的消息实现一个版本的方法。另外，你在你编码的时候，你可能不知道所有你需要转发的消息。因为这个可能需要依赖运行时的事件，而且还有可能在未来这些方法被修改为一个新的实现。 forwardInvocation:方法提供了一个第二种不是那么挫的方法来解决这个问题，而且这个方法还是动态的。它的原理如下:当一个对象因为没有方法来匹配一个消息而导致它无法响应这个消息的时候，runtime调用这个对象的forwardInvocation:方法来通知它。每一个对象都结成NSObject的这个方法。但是NSObject的这个方法只是简单的调用了doesNotRecognizeSelector:方法。重载NSObject的这个方法，你可以利用这个机会讲消息转发到其他对象。 要转发消息，forwardInvocation:的实现只需要做到下面的事情:1.确定消息应该发送到哪里；2.带着它的原始参数转发他。 消息转发可以使用invokeWithTarget:方法: `- (void)forwardInvocation:(NSInvocation *)anInvocation { if ([someOtherObject respondsToSelector:[anInvocation selector]]) [anInvocation invokeWithTarget:someOtherObject]; else [super forwardInvocation:anInvocation]; }` 这个被转发的消息的返回值呗返回给原来发出这个消息的对象。包含id，struct，double，float的所有类型的返回值都可以被传递。 forwardInvocation:可以作为一个未识别消息的转发中心，将所有的未识别消息转发给不同接受者。也可以作为转发站，转发所有未识别消息到相同对象。它可以将一个消息变成另外一个，也可以简单的"吞掉"这个消息来不返回值同时不产生错误。还可以对多个消息做相同的回应。它的实现完全取决于它的实现，但他所提供的转发链对程序设计是开放的。 NOTE:forwardInvocation:方法只有当消息无法触发一个存在的方法的时候才会被调用来处理问题。比如，你想要你的对象转发negotiate消息到其他对象，你的对象本身就不能实现这个方法。否则，这个消息永远无法被forwardInvocation:方法处理。 查询Foundation framework的NSInvocation类说明来获取更多关于转发和消息出发的信息。 **转发和多重继承** 转发可以模仿继承，所以可以被用来在OC中引入类似于多重继承的效果。就像下图显示，一个对象通过表现为借用或者"继承"的转发一个消息到另一个类的方法实现来响应一个消息。 [![1](http://www.karsa.info/wp-content/uploads/2014/12/1-300x191.png)](http://www.karsa.info/wp-content/uploads/2014/12/1.png) 在这个例子中，Warrior类对象转发一个negotiate消息到一个Diplomat对象。Warrior会响应negotiate消息(虽然实际上是跟Diplomat在实现)，并且会表现的跟Diplomat一样。 转发消息的对象因此"继承"了两个继承分之的方法，他自己所在的分支和响应这个消息的对象。在上面的例子中，Warrior类就像继承了他自己的superclass一样继承了Diplomat类。 转发提供了大部分你想要的多重继承的特性。但是两者有一个重要的区别:多重继承讲不同的特性集成到一个对象中，它趋向于建立一个大型的、多功能的对象。而转发，在另一方面，讲不同的职责分配给不同的对象，它将问题分解为更小的对象，但是将所有的功能用一种对使用者透明的方式联系起来。 **代替对象** 转发不仅仅模仿了多重继承，它还为开发轻量级的对象来代表或者"覆盖"更多的实质上起作用的对象提供可能。这样的替代，是为了其他对象以及发送给他们的漏斗消息。 在The Objective-C Programming Language的“Remote Messaging” 中讨论过的代理就是这样的替代。代理处理所有消息转发到远程接受者的详情，确保参数在传递的过程中被正确的保存或复制以及其他应该做的事情。但它也不试图会做更多的事情，它不会复制远程对象的函数，只是简单的给了远程对象它的本地地址，一个它可以它可以在其他程序中获取消息的地方。 其他类型的代替也可以。比如，假设你有一个操作大量数据的对象－可能它创建了一个复杂的图片或者从磁盘文件读取了一个文件的内容，设置这个对象可能很耗费时间，所以你想要使用懒加载方式－当需要响应资源或者系统空闲的时候加载。同时你又需要这个对象有一个合适的内容来让程序的其他部分正常运行。 在这种情况下，你可以为它仅仅创建一个轻量的代替对象而不是一个完整加载的对象。这个对象可能仅仅依赖自己做一些事情，不如回答关于这些数据的问题，但大部分情况下，它仅仅是为大数据对象占位，当时机到来的时候转发消息给大数据对象。当代替对象的forwardInvocation:方法第一次收到其他对象的消息的时候，它应该保证这个大数据对象存在，如果没有，就创建它。所有大数据对象的消息传过代替对象，所以只要声誉的程序部分涉及到相应内容，使用代替对象和大数据对象是一样的。 **转发和继承** 虽然转发模仿继承，但是NSPObject类从来不混淆两者。类似respondsToSelector:和isKindOfClass:的方法仅仅在继承体系传递，从来不会去转发链。比如当一个Warrior对象被问及他是否响应negotiate消息: ` if ( [aWarrior respondsToSelector:@selector(negotiate)] ) ... ` 问题的答案是NO，即使它可以通过转发来无错误的响应这个消息。 在很多情况下，NO是正确答案，但也有可能不是。当你使用转发来设置一个代替对象或者扩展一个类的功能的时候，转发机制可能和继承一样是透明的。但是当你想要你的对象变现的跟它转发消息的对象继承一模一样的时候，你需要重新实现respondsToSelector:和isKindOfClass:方法来包含你自己的转发逻辑: ` - (BOOL)respondsToSelector:(SEL)aSelector { if ( [super respondsToSelector:aSelector] ) return YES; else { /* Here, test whether the aSelector message can * * be forwarded to another object and whether that * * object can respond to it. Return YES if it can. */ } return NO; }` 除了这两个方法意外，instancesRespondToSelector:也应该如此实现。如果使用协议，还应该包含conformsToProtocol:方法。同样的，如果一个对象转发任何它接受到的消息到远程对象，它应该有自己的methodSignatureForSelector:方法来返回最终想应该消息的方法的精确描述。比如，如果一个对象想要转发消息给他的替代对象，你应该如下实现methodSignatureForSelector:方法: ` - (NSMethodSignature*)methodSignatureForSelector:(SEL)selector { NSMethodSignature* signature = [super methodSignatureForSelector:selector]; if (!signature) { signature = [surrogate methodSignatureForSelector:selector]; } return signature; }` 你可以考虑将所有的转发逻辑放到私有代码的一个位置，包含包括了forwardInvocation:方法在内的所有方法，然后调用它。 NOTE:这是高级技巧，适用于其他方法都无效的场景，他不是对继承的代替。如果你要使用它，请确定你完全理解了转发消息的类和接受转发消息的类的行为。 这个部分提到的方法，在Foundation framework的NSObject类说明中有描述。对于invokeWithTarget:方法的信息，请查阅Foundation framework的NSInocation的类说明。