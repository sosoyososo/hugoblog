---
title: 'macho:从execve到dyld_start'
date: Mon, 16 Oct 2017 04:43:30 +0000
draft: false
tags: ['iOS', 'Objective-C']
---

apple 开源了macOS和iOS的内核xun,从一些开放的文档我们可以轻易的知道macOS与iOS中运行的可执行文件都是mach-O格式的。从开放的文档[apple文档中](https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html#//apple_ref/doc/uid/TP40001829-SW1)我们知道运行mach-o文件是从调用fork和execve开始的。而我们调试代码，能追寻到的最早一个函数是dyld的\_dyld\_start，那么execve是怎么调用到\_dyld\_start从而启动我们的程序的？ 当然最直观的想法就是直接去xun中搜索\_dyld\_start这个函数调用，然而并没有什么卵用，当然是没有任何结果。虽然事情复杂了，但并没有出乎意料之外，毕竟看过的都知道mach-o的load command列表中有LC\_ID\_DYLINKER，正是对dyld的路径的配置。也就是说dyld是一个外部可配置的配件，并不是必配，他的函数当然也不可能在kernel中写死。 那么事情来了，从xun中找不到dyld起点，我们先从dyld本身来看一下跟dyld起点相关的东西，哈哈，这次命令列表中就有： [![](http://www.karsa.info/blog/wp-content/uploads/2017/10/屏幕快照-2017-10-16-上午11.54.47.png)](http://www.karsa.info/blog/wp-content/uploads/2017/10/屏幕快照-2017-10-16-上午11.54.47.png) [![](http://www.karsa.info/blog/wp-content/uploads/2017/10/屏幕快照-2017-10-16-上午11.55.03.png)](http://www.karsa.info/blog/wp-content/uploads/2017/10/屏幕快照-2017-10-16-上午11.55.03.png) 看以看到LC\_UNIXTHREAD这个命令，后续的一系列寄存器名称中有一个的值正式dyld\_start函数的开始地址。让我们在xun中再看一下LC\_UNIXTHREAD，只有两个文件：bsd/kern/mach\_loader.c　跟　libkern/kxld/kxld\_object.c，不用想直接看第一个咯。马上找到　parse\_machfile　函数中　switch 中的这个case，它调用了load\_unixthread 正式我们要找的LC\_UNIXTHREAD命令对应加载点。继续追查 load\_unixthread 会看到 load\_threadentry 这个方法调用，继续追查，发现调用了 thread\_entrypoint ，这个方法里，我们看到了熟悉的 rip 指针，指向的正是 \_dyld\_start。 回溯向上的过程是： 1. thread\_entrypoint 函数发现了dyld\_start开始的地址在rip指向的位置，设置了参数entry\_point,返回success。 2. entry\_point 是 load\_threadentry 函数传递进来的指针，继续向上 3. load\_unixthread 创建了 mach\_vm\_offset\_t 类型的 addr，load\_threadentry 函数找到并这是了值，之后被设置到load\_result\_t类型结构体的entry\_point属性上，并进行了必要的位移。 4. parse\_machfile 调用一系列命令的加载，在LC\_UNIXTHREAD这个case中，指向了上面的步骤，获得了dyld\_start函数开始的位置，在load\_return\_t中返回到上层。 回溯parse\_machfile向上看能找到什么： 1. 调用了 parse\_machfile 的位置有两处， load\_machfile 和 load\_dylinker，但后者所有可以搜索到的调用都发生在本这个文件中，而前者则是在 bsd/kern/kern\_exec.c 中也有发生。 2. 看 kern\_exec.c 中调用 load\_machfile 的路径，向上查看发现是 exec\_mach\_imgact 函数 3. 再向上发现这个函数指针存储在一个结构体数组execsw中 4. 对这个数组的引用只有 exec\_activate\_image 5. 再向上则也有两处，\_\_mac\_execve 和 posix\_spawn ，而 \_\_mac\_execve 向上就是我们所需要的起点 execve 而两次回溯从后向前就是从 execve 到 dyld 的过程。 从execve到发现\_dyld\_start的过程： execve -> \_\_mac\_execve -> exec\_activate\_image -> exec\_mach\_imgact -> load\_machfile -> parse\_machfile -> load\_unixthread -> load\_threadentry -> thread\_entrypoint 在这期间主要做了几件事情: 1. 创建新的进程执行代码。 2. 使用传入的参数进行加载mach-o文件，解析mach-o文件，执行mach-o文件的命令。 3. 在执行mach-o文件命令的过程中\_dyld\_start被执行。 主要的过程是： 1. fork 一个进程 2. 在新的进程中，打开可执行文件 3. 检测可以执行文件是有效的macho文件 4. 加载dyld 5. dyld加载依赖库，绑定符号，启动程序 6. 调用/usr/lib/crt1.o中的标准入口函数（设置内核的运行时环境状态，然后调用C++的静态初始化函数，初始化OC运行时，跳转程序的main函数）